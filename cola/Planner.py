from cola.fundamental import BaseRole, BaseResponseFormat
from cola.prompt.planner_prompt import PlannerPrompt
from typing import List, Optional, Dict
from cola.utils.datatype import WorkflowEvent, RoleType
from cola.utils.data_utils import PrivateData
from cola.utils.agent_utils import RegisterAgent
from pydantic import BaseModel, Field
from enum import StrEnum

_rf_params = dict(
    role=RoleType.Planner,
    additional_branch_type=None,
    additional_branch_desc=None,
)


class PlannerResponseFormat(BaseResponseFormat(**_rf_params)):
    sub_tasks: List[str] = Field(
        ...,
        description="A list of subtasks generated by the yourself. Each subtask is a string When you can not complete the task, set `sub_tasks` to empty list []"
    )
    question: str = Field(
        ...,
        description="The questions the task is expected to answer and the format of the answers. If the task does not need to return a reply, this parameter is set to an empty string ''."
                    "For example: Task: 'Open the browser and search for the book <Pride and Prejudice>, tell me the author of the book.' Question: 'What is the author of the book?"
                    "Another example: Task: 'Open the browser and search for the book <Pride and Prejudice>' Question: ''"
    )


class PlannerAnswerBranchType(StrEnum):
    Continue = "Continue"
    NeedHumanFeedback = "NeedHumanFeedback"
    Unanswerable = "Unanswerable"


class PlannerAnswerFormat(BaseModel):
    answer: str = Field(
        ...,
        description="The answer to the question asked by the task. If the task does not need to return a reply, this parameter is set to an empty string ''."
    )
    branch: Optional[PlannerAnswerBranchType] = Field(
        ...,
        description="Determine the next step in the process, when you can give an answer to a question, set it to `Continue`."
                    " If you don't know how to complete the current task, you can ask for help like a human, set to `NeedHumanFeedback`."
                    " If the current question cannot be answered, it needs to be set to `Unanswerable`."
    )
    problem: str = Field(
        ...,
        description="When branch is not `Continue`, you need to describe the problem encountered in this parameter."
                    " For example, if you need to request human help, you need to describe the problem you can't solve and where you need human help to solve it."
    )


@RegisterAgent(ignore_capability=True)
class Planner(BaseRole):
    role = RoleType.Planner
    capability = "Generate coarse-grained subtasks based on tasks"

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.prompter: PlannerPrompt = PlannerPrompt(self.agents_capability)

        self.session_step = {
            "Execute Steps": [],
            "Experience": []
        }

    def branch_step(self, response: Dict, **kwargs) -> PrivateData:
        if (branch := response["branch"]) == "Continue":
            if response["handle_event"] == WorkflowEvent.Planner_make_sub_task:
                return PrivateData(
                    sender=self.role, receiver=RoleType.TaskScheduler,
                    event=WorkflowEvent.TaskScheduler_distribute_subtask,
                    message=response["message"],
                    sub_tasks=response["sub_tasks"]
                )
            elif response["handle_event"] == WorkflowEvent.task_accomplished:
                return PrivateData(
                    sender=self.role, receiver=RoleType.Interactor,
                    event=WorkflowEvent.task_accomplished,
                    answer=response["answer"]
                )
            else:
                raise ValueError(f"Unknown handle event: {response['handle_event']} in {self.role}")
        if branch == PlannerAnswerBranchType.Unanswerable:
            return PrivateData(
                sender=self.role, receiver=RoleType.Interactor,
                event=WorkflowEvent.task_accomplished,
                answer=response["answer"],
                message=response["problem"]
            )
        else:
            raise ValueError(f"Unknown branch type: {branch} in {self.role}")

    @BaseRole.register_event(WorkflowEvent.Planner_make_sub_task)
    def handle_make_sub_task(self, data: PrivateData, handoff: bool, **kwargs) -> Optional[PrivateData]:
        """
        expected keys:
            - task
            - problem
            - message
        """
        if "task" in data:
            self.cdc.session_context.task = data.task

        if not handoff:
            self.episodic_messages = [
                self.prompter.create_system_prompt(PlannerResponseFormat),
                *self.retrieve_long_term_memory(self.generate_summary())
            ]
            self.linked_messages = self.retrieve_short_term_memory()
            self.query_messages = [
                self.prompter.create_make_sub_task_user_prompt(data)
            ]
            origin_response, response = self.query(format_model=PlannerResponseFormat)
            if origin_response is None and response is None and self.cdc.switch_to is not None:
                return None
        else:
            origin_response, response = self.handoff_query()

        # record execution steps
        self.record_session_step(step=dict(
            sub_tasks=response["sub_tasks"], question=response["question"], branch=response["branch"]
        ))

        response["handle_event"] = WorkflowEvent.Planner_make_sub_task
        self.cdc.session_context.question = response["question"]

        self.store_short_term_memory({
            "Make a subtask plan": response["sub_tasks"],
            "Questions to be answered": response["question"],
            "Summary": response["summary"]
        })

        return self.branch_step(response, data=data)

    @BaseRole.register_event(WorkflowEvent.task_accomplished)
    def handle_task_accomplished(self, data: PrivateData, handoff: bool, **kwargs) -> Optional[PrivateData]:
        """
        excepted keys:
            - role_infos
        """
        if not handoff:
            # Generating an answer is the final step of the program, eliminating the need to retrieve long-term, short-term memory
            self.episodic_messages = [
                self.prompter.create_answer_system_prompt(PlannerAnswerFormat),
            ]
            self.query_messages = [
                self.prompter.create_answer_user_prompt(data)
            ]

            origin_response, response = self.query(format_model=PlannerAnswerFormat, linked_messages=[])
            if origin_response is None and response is None and self.cdc.switch_to is not None:
                return None
        else:
            origin_response, response = self.handoff_query()

        # record execution steps
        self.record_session_step(step=dict(answer=response["answer"], branch=response["branch"]))

        response["handle_event"] = WorkflowEvent.task_accomplished

        return self.branch_step(response, data=data)
