import uuid
from cola.fundamental import BaseMemory, BaseEmbedding, BaseVectorStore, BaseSummarization
from typing import Optional, List, Union, Any, Tuple, Dict
from pathlib import Path
from cola.utils.json_utils import save_json, load_json


class JsonChatMessageMemory(BaseMemory):
    def __init__(self, embedding: Optional[BaseEmbedding] = None,
                 vectorstore: Optional[BaseVectorStore] = None,
                 summarizer: Optional[BaseSummarization] = None):
        self.json_memory: Dict[str, List] = {}  # uuid: messages
        self.summary_dict: Dict[str, str] = {}  # uuid: summary

        self.embedding = embedding
        self.vectorstore = vectorstore
        self.summarizer = summarizer

    def get(self, session_id: str) -> List[Tuple[str, str]]:
        return self.json_memory.get(session_id, [])

    def add(self, session_id: Optional[str] = None,
            summary: str = None,
            messages: List[Dict] = None,
            mode: str = "cw") -> str:
        """
        Adding data to memory, messages should be a conversational message that is summarized as it is added and stored in the vectorstore.

        Parameter:
            session_id: Optional[str] = None
            summary: str = None, The summary of the message, used as the basis for retrieval, if None, it will be generated by the summarizer.
            messages: List[Tuple[str, str]] = None
            mode: str = "w", Write mode.
                "w" means write, in this case, if there is the same summary/session_id, the write will be canceled.
                "a" means append, in this case, if there is the same summary/session_id, the messages will be appended to the original record.
                "cw" means overwrite, if there is the same summary/session_id, the original record will be deleted.
        """
        if not messages:
            return ""
        if summary is None:
            summary = self.summarizer.summarize(messages=messages)

        # If the summary already exists in memory, set the session_id to the session_id for the summary
        is_exist = False
        if session_id is None:
            for k, v in self.summary_dict.items():
                if summary == v:
                    session_id = k
                    is_exist = True
        # If the summary does not exist in memory, check if the session_id exists
        if not is_exist and session_id is not None:
            if session_id in self.json_memory:
                is_exist = True

        # If the same summary/session_id exists
        if is_exist and mode == "cw":  # and is in “cw” mode, then the original record is deleted.
            self.delete(session_id)
            is_exist = False
        elif is_exist and mode == "w":  # and is in “w” mode, then session_id is returned and the write is canceled.
            return ""

        if session_id is None:
            session_id = str(uuid.uuid4()).replace("-", "")

        if session_id not in self.json_memory:
            self.json_memory[session_id] = []
        self.json_memory[session_id].extend(messages)

        if not is_exist:
            self.summary_dict[session_id] = summary  # 存储 summary
            summary_embedding = self.embedding.embed_query(summary)
            if session_id in self.vectorstore:
                self.vectorstore.delete([session_id])
            self.vectorstore.add_embeddings([session_id], [summary_embedding])
        return session_id

    def similarity_search(
            self, text: Union[str, Any], k: int = 4, score_threshold: Optional[float] = None, **kwargs: Any
    ) -> List[Union[str, Any]]:
        embedding = self.embedding.embed_query(text)
        key_and_score = self.vectorstore.similarity_search(embedding, k, score_threshold)
        session_ids = set([k for k, _ in key_and_score])
        histories = [self.get(session_id) for session_id in session_ids]
        return histories

    def delete(self, session_id: Optional[Union[List[str], str]] = None):
        if isinstance(session_id, str):
            session_id = [session_id]
        # If session_id is None, all session_ids are deleted.
        if session_id is None:
            session_id = self.summary_dict.keys()
        for i in session_id:
            if i in self.json_memory:
                del self.json_memory[i]
        self.vectorstore.delete(session_id)
        self.summary_dict = {k: v for k, v in self.summary_dict.items() if k not in session_id}

    def get_all_memory(self):
        return self.json_memory

    def save_memory(self, path: Union[str, Path], file_name: str):
        if isinstance(path, str):
            path = Path(path)
        if not path.exists():
            path.mkdir(parents=True)
        data = {"json_memory": self.json_memory, "summary_dict": self.summary_dict}
        save_json(path / f"{file_name}.json", data, indent=4)
        self.vectorstore.save_vectorstore(path, file_name)

    def load_memory(self, path: Union[str, Path], file_name: str):
        if isinstance(path, str):
            path = Path(path)
        if not path.exists():
            raise FileNotFoundError(f"File {path} not found!.")
        self.vectorstore = self.vectorstore.load_vectorstore(path, file_name)
        data = load_json(path / f"{file_name}.json")
        self.json_memory = data["json_memory"]
        self.summary_dict = data["summary_dict"]
        return self


class JsonStringMemory(JsonChatMessageMemory):
    def __init__(self, embedding: Optional[BaseEmbedding] = None,
                 vectorstore: Optional[BaseVectorStore] = None):
        super().__init__(embedding, vectorstore)
        self.json_memory: Dict[str, str] = {}

    def get(self, session_id: str) -> str:
        return self.json_memory.get(session_id, "")

    def add(self, session_id: Optional[str] = None, summary: str = None, store: str = None) -> str:
        if session_id is None:
            session_id = str(uuid.uuid4()).replace("-", "")
        if session_id not in self.json_memory:
            self.json_memory[session_id] = ""
        self.json_memory[session_id] = store

        summary_embedding = self.embedding.embed_query(summary)
        if session_id in self.vectorstore:
            self.vectorstore.delete([session_id])
        self.vectorstore.add_embeddings([session_id], [summary_embedding])
        return session_id
